package org.xiph.vorbis;

import java.util.Arrays;

/**
 * psychoacoustic setup
 */
class LookPsy implements Comparator {
    // masking.h
    /**
     * more detailed ATH; the bass if flat to save stressing the floor
     * overly for only a bin or two of savings.
     */
    private static final int MAX_ATH = 88;
    private static final float ATH[] = {
            /*15*/  -51, -52, -53, -54, -55, -56, -57, -58,
            /*31*/  -59, -60, -61, -62, -63, -64, -65, -66,
            /*63*/  -67, -68, -69, -70, -71, -72, -73, -74,
            /*125*/ -75, -76, -77, -78, -80, -81, -82, -83,
            /*250*/ -84, -85, -86, -87, -88, -88, -89, -89,
            /*500*/ -90, -91, -91, -92, -93, -94, -95, -96,
            /*1k*/  -96, -97, -98, -98, -99, -99, -100, -100,
            /*2k*/ -101, -102, -103, -104, -106, -107, -107, -107,
            /*4k*/ -107, -105, -103, -102, -101, -99, -98, -96,
            /*8k*/  -95, -95, -96, -97, -96, -95, -93, -90,
            /*16k*/ -80, -70, -50, -40, -30, -30, -30, -30
    };
    // psy.h
    private static final float NEGINF = -9999.f;
    private static final float stereo_threshholds[] = {0.0f, .5f, 1.0f, 1.5f, 2.5f, 4.5f, 8.5f, 16.5f, 9e10f};
    private static final float stereo_threshholds_limited[] = {0.0f, .5f, 1.0f, 1.5f, 2.0f, 2.5f, 4.5f, 8.5f, 9e10f};
    static final int NOISE_COMPAND_LEVELS = 40;
    /* The tone masking curves from Ehmer's and Fielder's papers have been
	   replaced by an empirically collected data set.  The previously
	   published values were, far too often, simply on crack. */
    private static final int EHMER_OFFSET = 16;
    private static final int EHMER_MAX = 56;
    /**
     * masking tones from -50 to 0dB, 62.5 through 16kHz at half octaves
     * test tones from -2 octaves to +5 octaves sampled at eighth octaves<p>
     * (Vorbis 0dB, the loudest possible tone, is assumed to be ~100dB SPL
     * for collection of these curves)
     */
    private static final float[][][] tonemasks = new float[][][]{// [P_BANDS][6][EHMER_MAX]
            /* 62.5 Hz */
            {{-60, -60, -60, -60, -60, -60, -60, -60,
                    -60, -60, -60, -60, -62, -62, -65, -73,
                    -69, -68, -68, -67, -70, -70, -72, -74,
                    -75, -79, -79, -80, -83, -88, -93, -100,
                    -110, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-48, -48, -48, -48, -48, -48, -48, -48,
                            -48, -48, -48, -48, -48, -53, -61, -66,
                            -66, -68, -67, -70, -76, -76, -72, -73,
                            -75, -76, -78, -79, -83, -88, -93, -100,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-37, -37, -37, -37, -37, -37, -37, -37,
                            -38, -40, -42, -46, -48, -53, -55, -62,
                            -65, -58, -56, -56, -61, -60, -65, -67,
                            -69, -71, -77, -77, -78, -80, -82, -84,
                            -88, -93, -98, -106, -112, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-25, -25, -25, -25, -25, -25, -25, -25,
                            -25, -26, -27, -29, -32, -38, -48, -52,
                            -52, -50, -48, -48, -51, -52, -54, -60,
                            -67, -67, -66, -68, -69, -73, -73, -76,
                            -80, -81, -81, -85, -85, -86, -88, -93,
                            -100, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-16, -16, -16, -16, -16, -16, -16, -16,
                            -17, -19, -20, -22, -26, -28, -31, -40,
                            -47, -39, -39, -40, -42, -43, -47, -51,
                            -57, -52, -55, -55, -60, -58, -62, -63,
                            -70, -67, -69, -72, -73, -77, -80, -82,
                            -83, -87, -90, -94, -98, -104, -115, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-8, -8, -8, -8, -8, -8, -8, -8,
                            -8, -8, -10, -11, -15, -19, -25, -30,
                            -34, -31, -30, -31, -29, -32, -35, -42,
                            -48, -42, -44, -46, -50, -50, -51, -52,
                            -59, -54, -55, -55, -58, -62, -63, -66,
                            -72, -73, -76, -75, -78, -80, -80, -81,
                            -84, -88, -90, -94, -98, -101, -106, -110}},
            /* 88Hz */
            {{-66, -66, -66, -66, -66, -66, -66, -66,
                    -66, -66, -66, -66, -66, -67, -67, -67,
                    -76, -72, -71, -74, -76, -76, -75, -78,
                    -79, -79, -81, -83, -86, -89, -93, -97,
                    -100, -105, -110, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-47, -47, -47, -47, -47, -47, -47, -47,
                            -47, -47, -47, -48, -51, -55, -59, -66,
                            -66, -66, -67, -66, -68, -69, -70, -74,
                            -79, -77, -77, -78, -80, -81, -82, -84,
                            -86, -88, -91, -95, -100, -108, -116, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-36, -36, -36, -36, -36, -36, -36, -36,
                            -36, -37, -37, -41, -44, -48, -51, -58,
                            -62, -60, -57, -59, -59, -60, -63, -65,
                            -72, -71, -70, -72, -74, -77, -76, -78,
                            -81, -81, -80, -83, -86, -91, -96, -100,
                            -105, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-28, -28, -28, -28, -28, -28, -28, -28,
                            -28, -30, -32, -32, -33, -35, -41, -49,
                            -50, -49, -47, -48, -48, -52, -51, -57,
                            -65, -61, -59, -61, -64, -69, -70, -74,
                            -77, -77, -78, -81, -84, -85, -87, -90,
                            -92, -96, -100, -107, -112, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-19, -19, -19, -19, -19, -19, -19, -19,
                            -20, -21, -23, -27, -30, -35, -36, -41,
                            -46, -44, -42, -40, -41, -41, -43, -48,
                            -55, -53, -52, -53, -56, -59, -58, -60,
                            -67, -66, -69, -71, -72, -75, -79, -81,
                            -84, -87, -90, -93, -97, -101, -107, -114,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-9, -9, -9, -9, -9, -9, -9, -9,
                            -11, -12, -12, -15, -16, -20, -23, -30,
                            -37, -34, -33, -34, -31, -32, -32, -38,
                            -47, -44, -41, -40, -47, -49, -46, -46,
                            -58, -50, -50, -54, -58, -62, -64, -67,
                            -67, -70, -72, -76, -79, -83, -87, -91,
                            -96, -100, -104, -110, -999, -999, -999, -999}},
            /* 125 Hz */
            {{-62, -62, -62, -62, -62, -62, -62, -62,
                    -62, -62, -63, -64, -66, -67, -66, -68,
                    -75, -72, -76, -75, -76, -78, -79, -82,
                    -84, -85, -90, -94, -101, -110, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-59, -59, -59, -59, -59, -59, -59, -59,
                            -59, -59, -59, -60, -60, -61, -63, -66,
                            -71, -68, -70, -70, -71, -72, -72, -75,
                            -81, -78, -79, -82, -83, -86, -90, -97,
                            -103, -113, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-53, -53, -53, -53, -53, -53, -53, -53,
                            -53, -54, -55, -57, -56, -57, -55, -61,
                            -65, -60, -60, -62, -63, -63, -66, -68,
                            -74, -73, -75, -75, -78, -80, -80, -82,
                            -85, -90, -96, -101, -108, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-46, -46, -46, -46, -46, -46, -46, -46,
                            -46, -46, -47, -47, -47, -47, -48, -51,
                            -57, -51, -49, -50, -51, -53, -54, -59,
                            -66, -60, -62, -67, -67, -70, -72, -75,
                            -76, -78, -81, -85, -88, -94, -97, -104,
                            -112, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-36, -36, -36, -36, -36, -36, -36, -36,
                            -39, -41, -42, -42, -39, -38, -41, -43,
                            -52, -44, -40, -39, -37, -37, -40, -47,
                            -54, -50, -48, -50, -55, -61, -59, -62,
                            -66, -66, -66, -69, -69, -73, -74, -74,
                            -75, -77, -79, -82, -87, -91, -95, -100,
                            -108, -115, -999, -999, -999, -999, -999, -999},
                    {-28, -26, -24, -22, -20, -20, -23, -29,
                            -30, -31, -28, -27, -28, -28, -28, -35,
                            -40, -33, -32, -29, -30, -30, -30, -37,
                            -45, -41, -37, -38, -45, -47, -47, -48,
                            -53, -49, -48, -50, -49, -49, -51, -52,
                            -58, -56, -57, -56, -60, -61, -62, -70,
                            -72, -74, -78, -83, -88, -93, -100, -106}},
            /* 177 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -110, -105, -100, -95, -91, -87, -83,
                    -80, -78, -76, -78, -78, -81, -83, -85,
                    -86, -85, -86, -87, -90, -97, -107, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -110, -105, -100, -95, -90,
                            -85, -81, -77, -73, -70, -67, -67, -68,
                            -75, -73, -70, -69, -70, -72, -75, -79,
                            -84, -83, -84, -86, -88, -89, -89, -93,
                            -98, -105, -112, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-105, -100, -95, -90, -85, -80, -76, -71,
                            -68, -68, -65, -63, -63, -62, -62, -64,
                            -65, -64, -61, -62, -63, -64, -66, -68,
                            -73, -73, -74, -75, -76, -81, -83, -85,
                            -88, -89, -92, -95, -100, -108, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-80, -75, -71, -68, -65, -63, -62, -61,
                            -61, -61, -61, -59, -56, -57, -53, -50,
                            -58, -52, -50, -50, -52, -53, -54, -58,
                            -67, -63, -67, -68, -72, -75, -78, -80,
                            -81, -81, -82, -85, -89, -90, -93, -97,
                            -101, -107, -114, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-65, -61, -59, -57, -56, -55, -55, -56,
                            -56, -57, -55, -53, -52, -47, -44, -44,
                            -50, -44, -41, -39, -39, -42, -40, -46,
                            -51, -49, -50, -53, -54, -63, -60, -61,
                            -62, -66, -66, -66, -70, -73, -74, -75,
                            -76, -75, -79, -85, -89, -91, -96, -102,
                            -110, -999, -999, -999, -999, -999, -999, -999},
                    {-52, -50, -49, -49, -48, -48, -48, -49,
                            -50, -50, -49, -46, -43, -39, -35, -33,
                            -38, -36, -32, -29, -32, -32, -32, -35,
                            -44, -39, -38, -38, -46, -50, -45, -46,
                            -53, -50, -50, -50, -54, -54, -53, -53,
                            -56, -57, -59, -66, -70, -72, -74, -79,
                            -83, -85, -90, -97, -114, -999, -999, -999}},
            /* 250 Hz */
            {{-999, -999, -999, -999, -999, -999, -110, -105,
                    -100, -95, -90, -86, -80, -75, -75, -79,
                    -80, -79, -80, -81, -82, -88, -95, -103,
                    -110, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -108, -103, -98, -93,
                            -88, -83, -79, -78, -75, -71, -67, -68,
                            -73, -73, -72, -73, -75, -77, -80, -82,
                            -88, -93, -100, -107, -114, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -110, -105, -101, -96, -90,
                            -86, -81, -77, -73, -69, -66, -61, -62,
                            -66, -64, -62, -65, -66, -70, -72, -76,
                            -81, -80, -84, -90, -95, -102, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -107, -103, -97, -92, -88,
                            -83, -79, -74, -70, -66, -59, -53, -58,
                            -62, -55, -54, -54, -54, -58, -61, -62,
                            -72, -70, -72, -75, -78, -80, -81, -80,
                            -83, -83, -88, -93, -100, -107, -115, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -105, -100, -95, -90, -85,
                            -80, -75, -70, -66, -62, -56, -48, -44,
                            -48, -46, -46, -43, -46, -48, -48, -51,
                            -58, -58, -59, -60, -62, -62, -61, -61,
                            -65, -64, -65, -68, -70, -74, -75, -78,
                            -81, -86, -95, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -105, -100, -95, -90, -85, -80,
                            -75, -70, -65, -61, -55, -49, -39, -33,
                            -40, -35, -32, -38, -40, -33, -35, -37,
                            -46, -41, -45, -44, -46, -42, -45, -46,
                            -52, -50, -50, -50, -54, -54, -55, -57,
                            -62, -64, -66, -68, -70, -76, -81, -90,
                            -100, -110, -999, -999, -999, -999, -999, -999}},
            /* 354 hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -105, -98, -90, -85, -82, -83, -80, -78,
                    -84, -79, -80, -83, -87, -89, -91, -93,
                    -99, -106, -117, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -98, -90, -85, -80, -75, -70, -68,
                            -74, -72, -74, -77, -80, -82, -85, -87,
                            -92, -89, -91, -95, -100, -106, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -98, -90, -83, -75, -71, -63, -64,
                            -67, -62, -64, -67, -70, -73, -77, -81,
                            -84, -83, -85, -89, -90, -93, -98, -104,
                            -109, -114, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -103, -96, -88, -81, -75, -68, -58, -54,
                            -56, -54, -56, -56, -58, -60, -63, -66,
                            -74, -69, -72, -72, -75, -74, -77, -81,
                            -81, -82, -84, -87, -93, -96, -99, -104,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -108, -102, -96,
                            -91, -85, -80, -74, -68, -60, -51, -46,
                            -48, -46, -43, -45, -47, -47, -49, -48,
                            -56, -53, -55, -58, -57, -63, -58, -60,
                            -66, -64, -67, -70, -70, -74, -77, -84,
                            -86, -89, -91, -93, -94, -101, -109, -118,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -108, -103, -98, -93, -88,
                            -83, -78, -73, -68, -60, -53, -44, -35,
                            -38, -38, -34, -34, -36, -40, -41, -44,
                            -51, -45, -46, -47, -46, -54, -50, -49,
                            -50, -50, -50, -51, -54, -57, -58, -60,
                            -66, -66, -66, -64, -65, -68, -77, -82,
                            -87, -95, -110, -999, -999, -999, -999, -999}},
            /* 500 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -107, -102, -97, -92, -87, -83, -78, -75,
                    -82, -79, -83, -85, -89, -92, -95, -98,
                    -101, -105, -109, -113, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -106,
                            -100, -95, -90, -86, -81, -78, -74, -69,
                            -74, -74, -76, -79, -83, -84, -86, -89,
                            -92, -97, -93, -100, -103, -107, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -100,
                            -95, -90, -87, -83, -80, -75, -69, -60,
                            -66, -66, -68, -70, -74, -78, -79, -81,
                            -81, -83, -84, -87, -93, -96, -99, -103,
                            -107, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -108, -103, -98,
                            -93, -89, -85, -82, -78, -71, -62, -55,
                            -58, -58, -54, -54, -55, -59, -61, -62,
                            -70, -66, -66, -67, -70, -72, -75, -78,
                            -84, -84, -84, -88, -91, -90, -95, -98,
                            -102, -103, -106, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -108, -103, -98, -94,
                            -90, -87, -82, -79, -73, -67, -58, -47,
                            -50, -45, -41, -45, -48, -44, -44, -49,
                            -54, -51, -48, -47, -49, -50, -51, -57,
                            -58, -60, -63, -69, -70, -69, -71, -74,
                            -78, -82, -90, -95, -101, -105, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -105, -101, -97, -93, -90,
                            -85, -80, -77, -72, -65, -56, -48, -37,
                            -40, -36, -34, -40, -50, -47, -38, -41,
                            -47, -38, -35, -39, -38, -43, -40, -45,
                            -50, -45, -44, -47, -50, -55, -48, -48,
                            -52, -66, -70, -76, -82, -90, -97, -105,
                            -110, -999, -999, -999, -999, -999, -999, -999}},
            /* 707 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -108, -103, -98, -93, -86, -79, -76,
                    -83, -81, -85, -87, -89, -93, -98, -102,
                    -107, -112, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -108, -103, -98, -93, -86, -79, -71,
                            -77, -74, -77, -79, -81, -84, -85, -90,
                            -92, -93, -92, -98, -101, -108, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -108, -103, -98, -93, -87, -78, -68, -65,
                            -66, -62, -65, -67, -70, -73, -75, -78,
                            -82, -82, -83, -84, -91, -93, -98, -102,
                            -106, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -100, -95, -90, -82, -74, -62, -57,
                            -58, -56, -51, -52, -52, -54, -54, -58,
                            -66, -59, -60, -63, -66, -69, -73, -79,
                            -83, -84, -80, -81, -81, -82, -88, -92,
                            -98, -105, -113, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -102, -97, -92, -84, -79, -69, -57, -47,
                            -52, -47, -44, -45, -50, -52, -42, -42,
                            -53, -43, -43, -48, -51, -56, -55, -52,
                            -57, -59, -61, -62, -67, -71, -78, -83,
                            -86, -94, -98, -103, -110, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -105, -100,
                            -95, -90, -84, -78, -70, -61, -51, -41,
                            -40, -38, -40, -46, -52, -51, -41, -40,
                            -46, -40, -38, -38, -41, -46, -41, -46,
                            -47, -43, -43, -45, -41, -45, -56, -67,
                            -68, -83, -87, -90, -95, -102, -107, -113,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 1000 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -109, -105, -101, -96, -91, -84, -77,
                    -82, -82, -85, -89, -94, -100, -106, -110,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -106, -103, -98, -92, -85, -80, -71,
                            -75, -72, -76, -80, -84, -86, -89, -93,
                            -100, -107, -113, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -104, -101, -97, -92, -88, -84, -80, -64,
                            -66, -63, -64, -66, -69, -73, -77, -83,
                            -83, -86, -91, -98, -104, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -104, -101, -97, -92, -90, -84, -74, -57,
                            -58, -52, -55, -54, -50, -52, -50, -52,
                            -63, -62, -69, -76, -77, -78, -78, -79,
                            -82, -88, -94, -100, -106, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -102,
                            -98, -95, -90, -85, -83, -78, -70, -50,
                            -50, -41, -44, -49, -47, -50, -50, -44,
                            -55, -46, -47, -48, -48, -54, -49, -49,
                            -58, -62, -71, -81, -87, -92, -97, -102,
                            -108, -114, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -102,
                            -98, -95, -90, -85, -83, -78, -70, -45,
                            -43, -41, -47, -50, -51, -50, -49, -45,
                            -47, -41, -44, -41, -39, -43, -38, -37,
                            -40, -41, -44, -50, -58, -65, -73, -79,
                            -85, -92, -97, -101, -105, -109, -113, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 1414 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -107, -100, -95, -87, -81,
                    -85, -83, -88, -93, -100, -107, -114, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -107, -101, -95, -88, -83, -76,
                            -73, -72, -79, -84, -90, -95, -100, -105,
                            -110, -115, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -104, -98, -92, -87, -81, -70,
                            -65, -62, -67, -71, -74, -80, -85, -91,
                            -95, -99, -103, -108, -111, -114, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -103, -97, -90, -85, -76, -60,
                            -56, -54, -60, -62, -61, -56, -63, -65,
                            -73, -74, -77, -75, -78, -81, -86, -87,
                            -88, -91, -94, -98, -103, -110, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -105,
                            -100, -97, -92, -86, -81, -79, -70, -57,
                            -51, -47, -51, -58, -60, -56, -53, -50,
                            -58, -52, -50, -50, -53, -55, -64, -69,
                            -71, -85, -82, -78, -81, -85, -95, -102,
                            -112, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -105,
                            -100, -97, -92, -85, -83, -79, -72, -49,
                            -40, -43, -43, -54, -56, -51, -50, -40,
                            -43, -38, -36, -35, -37, -38, -37, -44,
                            -54, -60, -57, -60, -70, -75, -84, -92,
                            -103, -112, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 2000 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -110, -102, -95, -89, -82,
                    -83, -84, -90, -92, -99, -107, -113, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -107, -101, -95, -89, -83, -72,
                            -74, -78, -85, -88, -88, -90, -92, -98,
                            -105, -111, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -109, -103, -97, -93, -87, -81, -70,
                            -70, -67, -75, -73, -76, -79, -81, -83,
                            -88, -89, -97, -103, -110, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -107, -100, -94, -88, -83, -75, -63,
                            -59, -59, -63, -66, -60, -62, -67, -67,
                            -77, -76, -81, -88, -86, -92, -96, -102,
                            -109, -116, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -105, -98, -92, -86, -81, -73, -56,
                            -52, -47, -55, -60, -58, -52, -51, -45,
                            -49, -50, -53, -54, -61, -71, -70, -69,
                            -78, -79, -87, -90, -96, -104, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -103, -96, -90, -86, -78, -70, -51,
                            -42, -47, -48, -55, -54, -54, -53, -42,
                            -35, -28, -33, -38, -37, -44, -47, -49,
                            -54, -63, -68, -78, -82, -89, -94, -99,
                            -104, -109, -114, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 2828 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -110, -100, -90, -79,
                    -85, -81, -82, -82, -89, -94, -99, -103,
                    -109, -115, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -105, -97, -85, -72,
                            -74, -70, -70, -70, -76, -85, -91, -93,
                            -97, -103, -109, -115, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -112, -93, -81, -68,
                            -62, -60, -60, -57, -63, -70, -77, -82,
                            -90, -93, -98, -104, -109, -113, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -113, -100, -93, -84, -63,
                            -58, -48, -53, -54, -52, -52, -57, -64,
                            -66, -76, -83, -81, -85, -85, -90, -95,
                            -98, -101, -103, -106, -108, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -105, -95, -86, -74, -53,
                            -50, -38, -43, -49, -43, -42, -39, -39,
                            -46, -52, -57, -56, -72, -69, -74, -81,
                            -87, -92, -94, -97, -99, -102, -105, -108,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -108, -99, -90, -76, -66, -45,
                            -43, -41, -44, -47, -43, -47, -40, -30,
                            -31, -31, -39, -33, -40, -41, -43, -53,
                            -59, -70, -73, -77, -79, -82, -84, -87,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 4000 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -110, -91, -76,
                    -75, -85, -93, -98, -104, -110, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -91, -70,
                            -70, -75, -86, -89, -94, -98, -101, -106,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -60,
                            -65, -64, -74, -83, -88, -91, -95, -99,
                            -103, -107, -110, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -58,
                            -55, -49, -66, -68, -71, -78, -78, -80,
                            -88, -85, -89, -97, -100, -105, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -53,
                            -52, -41, -59, -59, -49, -58, -56, -63,
                            -86, -79, -90, -93, -98, -103, -107, -112,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -97, -91, -73, -45,
                            -40, -33, -53, -61, -49, -54, -50, -50,
                            -60, -52, -67, -74, -81, -92, -96, -100,
                            -105, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 5657 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -113, -106, -99, -92, -77,
                    -80, -88, -97, -106, -115, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -116, -109, -102, -95, -89, -74,
                            -72, -88, -87, -95, -102, -109, -116, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -116, -109, -102, -95, -89, -75,
                            -66, -74, -77, -78, -86, -87, -90, -96,
                            -105, -115, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -115, -108, -101, -94, -88, -66,
                            -56, -61, -70, -65, -78, -72, -83, -84,
                            -93, -98, -105, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -110, -105, -95, -89, -82, -57,
                            -52, -52, -59, -56, -59, -58, -69, -67,
                            -88, -82, -82, -89, -94, -100, -108, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -110, -101, -96, -90, -83, -77, -54,
                            -43, -38, -50, -48, -52, -48, -42, -42,
                            -51, -52, -53, -59, -65, -71, -78, -85,
                            -95, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 8000 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -120, -105, -86, -68,
                    -78, -79, -90, -100, -110, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -120, -105, -86, -66,
                            -73, -77, -88, -96, -105, -115, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -120, -105, -92, -80, -61,
                            -64, -68, -80, -87, -92, -100, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -120, -104, -91, -79, -52,
                            -60, -54, -64, -69, -77, -80, -82, -84,
                            -85, -87, -88, -90, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -118, -100, -87, -77, -49,
                            -50, -44, -58, -61, -61, -67, -65, -62,
                            -62, -62, -65, -68, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -115, -98, -84, -62, -49,
                            -44, -38, -46, -49, -49, -46, -39, -37,
                            -39, -40, -42, -43, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 11314 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -110, -88, -74,
                    -77, -82, -82, -85, -90, -94, -99, -104,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -88, -66,
                            -70, -81, -80, -81, -84, -88, -91, -93,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -88, -61,
                            -63, -70, -71, -74, -77, -80, -83, -85,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -86, -62,
                            -63, -62, -62, -58, -52, -50, -50, -52,
                            -54, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -118, -108, -84, -53,
                            -50, -50, -50, -55, -47, -45, -40, -40,
                            -40, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -118, -100, -73, -43,
                            -37, -42, -43, -53, -38, -37, -35, -35,
                            -38, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            /* 16000 Hz */
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -110, -100, -91, -84, -74,
                    -80, -80, -80, -80, -80, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -91, -84, -74,
                            -68, -68, -68, -68, -68, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -86, -78, -70,
                            -60, -45, -30, -21, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -87, -78, -67,
                            -48, -38, -29, -21, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -86, -69, -56,
                            -45, -35, -33, -29, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -83, -71, -48,
                            -27, -38, -37, -34, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}}
    };
    // psy.h
    /* psychoacoustic setup ********************************************/
    /**
     * 62Hz to 16kHz
     */
    static final int P_BANDS = 17;
    /**
     * 30dB to 100dB
     */
    private static final int P_LEVELS = 8;
    /**
     * 30 dB
     */
    private static final float P_LEVEL_0 = 30.f;
    static final int P_NOISECURVES = 3;
    //
    private int n = 0;
    private InfoPsy vi = null;

    private float[][][] tonecurves = null;
    private float[][] noiseoffset = null;

    private float[] ath = null;
    private int[] octave = null;             /* in n.ocshift format */
    private int[] bark = null;

    private int firstoc = 0;
    private int shiftoc = 0;
    private int eighth_octave_lines = 0; /* power of two, please */
    private int total_octave_lines = 0;
    // FIXME never used m_rate
    //private int rate = 0; /* cache it */

    private float val = 0.0f; /* Masking compensation value */

    //
    private final void clear() {
        n = 0;
        vi = null;

        tonecurves = null;
        noiseoffset = null;

        ath = null;
        octave = null;
        bark = null;

        firstoc = 0;
        shiftoc = 0;
        eighth_octave_lines = 0;
        total_octave_lines = 0;
        //m_rate = 0;

        val = 0.0f;
    }

    // psy.c
    private static void min_curve(final float[] c, final float[] c2) {
        for (int i = 0; i < EHMER_MAX; i++) {
            if (c2[i] < c[i]) {
                c[i] = c2[i];
            }
        }
    }

    private static void max_curve(final float[] c, final float[] c2) {
        for (int i = 0; i < EHMER_MAX; i++) {
            if (c2[i] > c[i]) {
                c[i] = c2[i];
            }
        }
    }

    private static void attenuate_curve(final float[] c, final float att) {
        for (int i = 0; i < EHMER_MAX; i++) {
            c[i] += att;
        }
    }

    private static float[][][] setup_tone_curves(final float[] curveatt_dB, final float binHz, final int n,
                                                 final float center_boost, final float center_decay_rate) {
        final float[] ath = new float[EHMER_MAX];
        final float[][][] workc = new float[P_BANDS][P_LEVELS][EHMER_MAX];// zeroed
        final float[][] athc = new float[P_LEVELS][EHMER_MAX];
        final float[] brute_buffer = new float[n];
        final float[][][] ret = new float[P_BANDS][P_LEVELS][EHMER_MAX + 2];

        for (int i = 0; i < P_BANDS; i++) {
			/* we add back in the ATH to avoid low level curves falling off to
			  -infinity and unnecessarily cutting off high level curves in the
			  curve limiting (last step). */

			/* A half-band's settings must be valid over the whole band, and
			   it's better to mask too little than too much */
            final int ath_offset = i << 2;
            for (int j = 0; j < EHMER_MAX; j++) {
                float min = 999.f;
                for (int k = 0; k < 4; k++) {
                    final int m = j + k + ath_offset;
                    if (m < MAX_ATH) {
                        if (min > ATH[m]) {
                            min = ATH[m];
                        }
                    } else {
                        if (min > ATH[MAX_ATH - 1]) {
                            min = ATH[MAX_ATH - 1];
                        }
                    }
                }
                ath[j] = min;
            }

			/* copy curves into working space, replicate the 50dB curve to 30
			and 40, replicate the 100dB curve to 110 */
            final float[][] tonemasks_i = tonemasks[i];// java
            final float[][] workc_i = workc[i];// java
            for (int j = 0; j < 6; j++) {
                System.arraycopy(tonemasks_i[j], 0, workc_i[j + 2], 0, EHMER_MAX);
            }
            System.arraycopy(tonemasks_i[0], 0, workc_i[0], 0, EHMER_MAX);
            System.arraycopy(tonemasks_i[0], 0, workc_i[1], 0, EHMER_MAX);

            /* apply centered curve boost/decay */
            for (int j = 0; j < P_LEVELS; j++) {
                for (int k = 0; k < EHMER_MAX; k++) {
                    int m = EHMER_OFFSET - k;
                    if (m < 0) {
                        m = -m;
                    }
                    float adj = center_boost + (float) m * center_decay_rate;
                    if (adj < 0. && center_boost > 0) {
                        adj = 0.f;
                    }
                    if (adj > 0. && center_boost < 0) {
                        adj = 0.f;
                    }
                    workc_i[j][k] += adj;
                }
            }

            /* normalize curves so the driving amplitude is 0dB */
            /* make temp curves with the ATH overlayed */
            for (int j = 0; j < P_LEVELS; j++) {
                attenuate_curve(workc_i[j], curveatt_dB[i] + 100.f - (j < 2 ? 2 : j) * 10.f - P_LEVEL_0);
                System.arraycopy(ath, 0, athc[j], 0, EHMER_MAX);
                attenuate_curve(athc[j], +100.f - j * 10.f - P_LEVEL_0);
                max_curve(athc[j], workc_i[j]);
            }

			/* Now limit the louder curves.

			the idea is this: We don't know what the playback attenuation
			will be; 0dB SL moves every time the user twiddles the volume
			knob. So that means we have to use a single 'most pessimal' curve
			for all masking amplitudes, right?  Wrong.  The *loudest* sound
			can be in (we assume) a range of ...+100dB] SL.  However, sounds
			20dB down will be in a range ...+80], 40dB down is from ...+60],
			etc... */

            for (int j = 1; j < P_LEVELS; j++) {
                min_curve(athc[j], athc[j - 1]);
                min_curve(workc_i[j], athc[j]);
            }
        }

        for (int i = 0; i < P_BANDS; i++) {
            // ret[i] = new float[P_LEVELS][]; already allocated

			/* low frequency curves are measured with greater resolution than
			the MDCT/FFT will actually give us; we want the curve applied
			to the tone data to be pessimistic and thus apply the minimum
			masking possible for a given bin.  That means that a single bin
			could span more than one octave and that the curve will be a
			composite of multiple octaves.  It also may mean that a single
			bin may span > an eighth of an octave and that the eighth
			octave values may also be composited. */

            /* which octave curves will we be compositing? */
            int bin = (int) Math.floor(Codec.fromOC(i * .5f) / binHz);
            int lo_curve = (int) Math.ceil(Codec.toOC(bin * binHz + 1) * 2);
            int hi_curve = (int) Math.floor(Codec.toOC((bin + 1) * binHz) * 2);
            if (lo_curve > i) {
                lo_curve = i;
            }
            if (lo_curve < 0) {
                lo_curve = 0;
            }
            if (hi_curve >= P_BANDS) {
                hi_curve = P_BANDS - 1;
            }

            for (int m = 0; m < P_LEVELS; m++) {
                //ret[i][m] = new float[EHMER_MAX + 2]; already allocated

                for (int j = 0; j < n; j++) {
                    brute_buffer[j] = 999.f;
                }

			/* render the curve into bins, then pull values back into curve.
			The point is that any inherent subsampling aliasing results in
			a safe minimum */
                for (int k = lo_curve; k <= hi_curve; k++) {
                    int l = 0;
                    final float[] w = workc[k][m];
                    float k2 = k * .5f;// java
                    final float k1 = k2 - 2.0625f;// java
                    k2 -= 1.9375f;// java

                    for (int j = 0; j < EHMER_MAX; j++) {
                        final float j8 = j * .125f;// java
                        int lo_bin = (int) (Codec.fromOC(j8 + k1) / binHz);
                        int hi_bin = (int) (Codec.fromOC(j8 + k2) / binHz) + 1;

                        if (lo_bin < 0) {
                            lo_bin = 0;
                        }
                        if (lo_bin > n) {
                            lo_bin = n;
                        }
                        if (lo_bin < l) {
                            l = lo_bin;
                        }
                        if (hi_bin < 0) {
                            hi_bin = 0;
                        }
                        if (hi_bin > n) {
                            hi_bin = n;
                        }

                        for (; l < hi_bin && l < n; l++) {
                            if (brute_buffer[l] > w[j]) {
                                brute_buffer[l] = w[j];
                            }
                        }
                    }

                    for (; l < n; l++) {
                        if (brute_buffer[l] > w[EHMER_MAX - 1]) {
                            brute_buffer[l] = w[EHMER_MAX - 1];
                        }
                    }

                }

                /* be equally paranoid about being valid up to next half ocatve */
                if (i + 1 < P_BANDS) {
                    int l = 0;
                    final int k = i + 1;
                    final float[] w = workc[k][m];
                    float i2 = i * .5f;// java
                    final float i1 = i2 - 2.0625f;// java
                    i2 -= 1.9375f;// java
                    for (int j = 0; j < EHMER_MAX; j++) {
                        final float j8 = j * .125f;// java
                        int lo_bin = (int) (Codec.fromOC(j8 + i1) / binHz);
                        int hi_bin = (int) (Codec.fromOC(j8 + i2) / binHz) + 1;

                        if (lo_bin < 0) {
                            lo_bin = 0;
                        }
                        if (lo_bin > n) {
                            lo_bin = n;
                        }
                        if (lo_bin < l) {
                            l = lo_bin;
                        }
                        if (hi_bin < 0) {
                            hi_bin = 0;
                        }
                        if (hi_bin > n) {
                            hi_bin = n;
                        }

                        for (; l < hi_bin && l < n; l++) {
                            if (brute_buffer[l] > w[j]) {
                                brute_buffer[l] = w[j];
                            }
                        }
                    }

                    for (; l < n; l++) {
                        if (brute_buffer[l] > w[EHMER_MAX - 1]) {
                            brute_buffer[l] = w[EHMER_MAX - 1];
                        }
                    }

                }

                final float[] r = ret[i][m];

                final float i5 = i * .5f - 2.f;// java
                for (int j = 0; j < EHMER_MAX; j++) {
                    bin = (int) (Codec.fromOC(j * .125f + i5) / binHz);
                    if (bin < 0) {
                        r[j + 2] = -999.f;
                    } else {
                        if (bin >= n) {
                            r[j + 2] = -999.f;
                        } else {
                            r[j + 2] = brute_buffer[bin];
                        }
                    }
                }

                /* add fenceposts */
                int j = 2;// java + 2
                for (; j < EHMER_OFFSET + 2; j++) {
                    if (r[j] > -200.f) {
                        break;
                    }
                }
                r[0] = j - 2;

                for (j = EHMER_MAX - 1 + 2; j > EHMER_OFFSET + 1 + 2; j--) {
                    if (r[j] > -200.f) {
                        break;
                    }
                }
                r[1] = j - 2;

            }
        }

        return (ret);
    }

    final void _init(final InfoPsy vinfo,
                     final InfoPsyGlobal gi, final int size, final int rate) {

        clear();// memset(p,0,sizeof(*p));

        this.eighth_octave_lines = gi.eighth_octave_lines;
        this.shiftoc = (int) Math.rint(Math.log(gi.eighth_octave_lines * 8.) / Math.log(2.)) - 1;

        this.firstoc = (int) (Codec.toOC(.25f * rate * .5f / size) * (1 << (this.shiftoc + 1)))
                - gi.eighth_octave_lines;
        final int maxoc = (int) (Codec.toOC((size + .25f) * rate * .5f / size) * (1 << (this.shiftoc + 1)) + .5f);
        this.total_octave_lines = maxoc - this.firstoc + 1;
        this.ath = new float[size];

        this.octave = new int[size];
        this.bark = new int[size];
        this.vi = vinfo;
        this.n = size;
        //this.m_rate = rate;

        /* AoTuV HF weighting */
        this.val = 1.f;
        if (rate < 26000) {
            this.val = 0;
        } else if (rate < 38000) {
            this.val = .94f;   /* 32kHz */
        } else if (rate > 46000) {
            this.val = 1.275f; /* 48kHz */
        }

        /* set up the lookups for a given blocksize and sample rate */
        final float[] a = this.ath;// java
        int j = 0;
        for (int i = 0; i < MAX_ATH - 1; i++) {
            final int endpos = (int) Math.rint(Codec.fromOC((i + 1) * .125f - 2.f) * 2 * size / rate);
            float base = ATH[i];
            if (j < endpos) {
                final float delta = (ATH[i + 1] - base) / (endpos - j);
                for (; j < endpos && j < size; j++) {
                    a[j] = base + 100.f;
                    base += delta;
                }
            }
        }

        for (; j < size; j++) {
            a[j] = a[j - 1];
        }

        int lo = -99, hi = 1;
        j = size << 1;
        final int rj = rate / j;// java
        for (int i = 0; i < size; i++) {
            final float fbark = Codec.toBARK((float) (rj * i));
            float b = fbark - vinfo.noisewindowlo;// java

            for (; lo + vinfo.noisewindowlomin < i &&
                    Codec.toBARK((float) (rj * lo)) < b; lo++) {
                ;
            }

            b = fbark + vinfo.noisewindowhi;// java
            for (; hi <= size && (hi < i + vinfo.noisewindowhimin ||
                    Codec.toBARK((float) (rj * hi)) < b); hi++) {
                ;
            }

            this.bark[i] = ((lo - 1) << 16) + (hi - 1);

        }

        final float tmp = (float) (1 << (this.shiftoc + 1));// java
        final int[] o = this.octave;// java
        for (int i = 0; i < size; i++) {
            o[i] = (int) (Codec.toOC((i + .25f) * .5f * rate / size) * tmp + .5f);
        }

        this.tonecurves = setup_tone_curves(vinfo.toneatt, rate * .5f / size, size,
                vinfo.tone_centerboost, vinfo.tone_decay);

        /* set up rolling noise median */
        final float[][] no = new float[P_NOISECURVES][size];
        this.noiseoffset = no;
        final float[][] noiseoff = this.vi.noiseoff;// java

        for (int i = 0; i < size; i++) {
            float halfoc = Codec.toOC((i + .5f) * rate / (2.f * size)) * 2.f;

            if (halfoc < 0) {
                halfoc = 0;
            }
            if (halfoc >= P_BANDS - 1) {
                halfoc = P_BANDS - 1;
            }
            final int inthalfoc = (int) halfoc;
            final float del = halfoc - inthalfoc;
            // FIXME bug: vi.noiseoff have size 16, [inthalfoc + 1] points out of bounds
			/*for( j = 0; j < P_NOISECURVES; j++ )
				this.m_noiseoffset[j][i] =
					this.m_vi.noiseoff[j][inthalfoc] * (1.f - del) +
					this.m_vi.noiseoff[j][inthalfoc + 1] * del;*/
            for (j = 0; j < P_NOISECURVES; j++) {
                if (inthalfoc >= P_BANDS - 1) {
                    if (j >= P_NOISECURVES - 1) {
                        no[j][i] = noiseoff[j][inthalfoc] * (1.0f - del);
                    } else {
                        no[j][i] = noiseoff[j][inthalfoc] * (1.0f - del) + noiseoff[j + 1][0] * del;
                    }
                } else {
                    no[j][i] = noiseoff[j][inthalfoc] * (1.0f - del) + noiseoff[j][inthalfoc + 1] * del;
                }
            }

        }
		/* #if 0
		{
			static int ls = 0;
			Analysis._analysis_output_always("noiseoff0", ls, noiseoffset[0], 0, n, true, false, 0);
			Analysis._analysis_output_always("noiseoff1", ls, noiseoffset[1], 0, n, true, false, 0);
			Analysis._analysis_output_always("noiseoff2", ls++, noiseoffset[2], 0, n, true, false, 0);
		}
		#endif */
    }

    final void _clear() {
        //int i, j;
        //if( p != null ) {
			/*if( this.m_ath != null ) this.m_ath = null;
			if( this.m_octave != null ) this.m_octave = null;
			if( this.m_bark != null ) this.m_bark = null;
			if( this.m_tonecurves != null ) {
				for( i = 0; i < P_BANDS; i++ ) {
					for( j = 0; j < P_LEVELS; j++ ) {
						this.m_tonecurves[i][j] = null;
					}
					this.m_tonecurves[i] = null;
				}
				this.m_tonecurves = null;
			}
			if( this.m_noiseoffset != null ) {
				for( i = 0; i < P_NOISECURVES; i++ ) {
					this.m_noiseoffset[i] = null;
				}
				this.m_noiseoffset = null;
			}*/
        clear();
        //}
    }

    /**
     * octave/(8*eighth_octave_lines) x scale and dB y scale
     */
    private static final void seed_curve(final float[] seed, final float[][] curves,
                                         final float amp, final int oc, final int n,
                                         final int linesper, final float dBoffset) {
        int choice = (int) ((amp + dBoffset - P_LEVEL_0) * .1f);
        if (choice < 0) {
            choice = 0;
        }
        if (choice > P_LEVELS - 1) {
            choice = P_LEVELS - 1;
        }
        final float[] posts = curves[choice];
        final int post1 = (int) posts[1] + 2;
        int seedptr = (int) (oc + (posts[0] - EHMER_OFFSET) * linesper - (linesper >> 1));

        for (int i = (int) posts[0] + 2; i < post1; i++) {
            if (seedptr > 0) {
                final float lin = amp + posts[i];
                if (seed[seedptr] < lin) {
                    seed[seedptr] = lin;
                }
            }
            seedptr += linesper;
            if (seedptr >= n) {
                break;
            }
        }
    }

    private final void seed_loop(final float[][][] curves,
                                 final float[] f, final float[] flr, final float[] seed, final float specmax) {
        final int size = this.n;
        final float dBoffset = this.vi.max_curve_dB - specmax;

        /* prime the working vector with peak values */
        final int[] o = this.octave;// java
        for (int i = 0; i < size; i++) {
            float max = f[i];
            int oc = o[i];
            while (i + 1 < size && o[i + 1] == oc) {
                i++;
                if (f[i] > max) {
                    max = f[i];
                }
            }

            if (max + 6.f > flr[i]) {
                oc >>= this.shiftoc;

                if (oc >= P_BANDS) {
                    oc = P_BANDS - 1;
                }
                if (oc < 0) {
                    oc = 0;
                }

                seed_curve(seed, curves[oc], max, o[i] - this.firstoc,
                        this.total_octave_lines, this.eighth_octave_lines,
                        dBoffset);
            }
        }
    }

    private static final void seed_chase(final float[] seeds, final int linesper, final int n) {
        final int[] posstack = new int[n];
        final float[] ampstack = new float[n];
        int stack = 0;
        int pos = 0;

        for (int i = 0; i < n; i++) {
            if (stack < 2) {
                posstack[stack] = i;
                ampstack[stack++] = seeds[i];
            } else {
                while (true) {
                    if (seeds[i] < ampstack[stack - 1]) {
                        posstack[stack] = i;
                        ampstack[stack++] = seeds[i];
                        break;
                    } else {
                        if (i < posstack[stack - 1] + linesper) {
                            if (stack > 1 && ampstack[stack - 1] <= ampstack[stack - 2] &&
                                    i < posstack[stack - 2] + linesper) {
                                /* we completely overlap, making stack-1 irrelevant.  pop it */
                                stack--;
                                continue;
                            }
                        }
                        posstack[stack] = i;
                        ampstack[stack++] = seeds[i];
                        break;
                    }
                }
            }
        }

		/* the stack now contains only the positions that are relevant. Scan
		 'em straight through */

        for (int i = 0; i < stack; i++) {
            int endpos;
            if (i < stack - 1 && ampstack[i + 1] > ampstack[i]) {
                endpos = posstack[i + 1];
            } else {
                endpos = posstack[i] + linesper + 1; /* +1 is important, else bin 0 is
													discarded in short frames */
            }
            if (endpos > n) {
                endpos = n;
            }
            for (; pos < endpos; pos++) {
                seeds[pos] = ampstack[i];
            }
        }

		/* there.  Linear time.  I now remember this was on a problem set I
		 had in Grad Skool... I didn't solve it at the time ;-) */

    }

    /**
     * bleaugh, this is more complicated than it needs to be
     */
    private final void max_seeds(final float[] seed, final float[] flr) {
        final int lines = this.total_octave_lines;
        final int linesper = this.eighth_octave_lines;

        seed_chase(seed, linesper, lines); /* for masking */

        final int[] o = this.octave;// java
        final int ft = this.firstoc;// java
        int pos = o[0] - ft - (linesper >> 1);

        final float tone_abs_limit = this.vi.tone_abs_limit;// java
        final int size = this.n;// java
        int linpos = 0;
        while (linpos + 1 < size) {
            float minV = seed[pos];
            int end = ((o[linpos] + o[linpos + 1]) >> 1) - ft;
            if (minV > tone_abs_limit) {
                minV = tone_abs_limit;
            }
            while (pos + 1 <= end) {
                pos++;
                if ((seed[pos] > NEGINF && seed[pos] < minV) || minV == NEGINF) {
                    minV = seed[pos];
                }
            }

            end = pos + ft;
            for (; linpos < size && o[linpos] <= end; linpos++) {
                if (flr[linpos] < minV) {
                    flr[linpos] = minV;
                }
            }
        }

        {
            final float minV = seed[lines - 1];
            for (; linpos < size; linpos++) {
                if (flr[linpos] < minV) {
                    flr[linpos] = minV;
                }
            }
        }

    }

    private static final void bark_noise_hybridmp(final int n, final int[] b,
                                                  final float[] f, int f_offset,
                                                  final float[] noise,
                                                  final float offset,
                                                  final int fixed) {

        final float[] N = new float[n];
        final float[] X = new float[n];
        final float[] XX = new float[n];
        final float[] Y = new float[n];
        final float[] XY = new float[n];

        float R = 0.f;
        float A = 0.f;
        float B = 0.f;
        float D = 1.f;

        float tN, tX, tXX, tY, tXY;
        tN = tX = tXX = tY = tXY = 0.f;

        float y = f[f_offset++] + offset;// to optimize f[f_offset + i]
        if (y < 1.f) {
            y = 1.f;
        }

        float w = y * y * .5f;

        tN += w;
        tX += w;
        tY += w * y;

        N[0] = tN;
        X[0] = tX;
        XX[0] = tXX;
        Y[0] = tY;
        XY[0] = tXY;

        int i;
        float x;
        for (i = 1, x = 1.f; i < n; i++, x += 1.f) {

            y = f[f_offset++] + offset;
            if (y < 1.f) {
                y = 1.f;
            }

            w = y * y;

            tN += w;
            tX += w * x;
            tXX += w * x * x;
            tY += w * y;
            tXY += w * x * y;

            N[i] = tN;
            X[i] = tX;
            XX[i] = tXX;
            Y[i] = tY;
            XY[i] = tXY;
        }

        for (i = 0, x = 0.f; ; i++, x += 1.f) {

            final int lo = b[i] >> 16;
            if (lo >= 0) {
                break;
            }
            final int hi = b[i] & 0xffff;

            tN = N[hi] + N[-lo];
            tX = X[hi] - X[-lo];
            tXX = XX[hi] + XX[-lo];
            tY = Y[hi] + Y[-lo];
            tXY = XY[hi] - XY[-lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;
            if (R < 0.f) {
                R = 0.f;
            }

            noise[i] = R - offset;
        }

        for (; ; i++, x += 1.f) {

            final int lo = b[i] >> 16;
            final int hi = b[i] & 0xffff;
            if (hi >= n) {
                break;
            }

            tN = N[hi] - N[lo];
            tX = X[hi] - X[lo];
            tXX = XX[hi] - XX[lo];
            tY = Y[hi] - Y[lo];
            tXY = XY[hi] - XY[lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;
            if (R < 0.f) {
                R = 0.f;
            }

            noise[i] = R - offset;
        }
        for (; i < n; i++, x += 1.f) {

            R = (A + x * B) / D;
            if (R < 0.f) {
                R = 0.f;
            }

            noise[i] = R - offset;
        }

        if (fixed <= 0) {
            return;
        }

        for (i = 0, x = 0.f; ; i++, x += 1.f) {
            final int hi = i + (fixed >> 1);
            final int lo = hi - fixed;
            if (lo >= 0) {
                break;
            }

            tN = N[hi] + N[-lo];
            tX = X[hi] - X[-lo];
            tXX = XX[hi] + XX[-lo];
            tY = Y[hi] + Y[-lo];
            tXY = XY[hi] - XY[-lo];


            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;

            if (R - offset < noise[i]) {
                noise[i] = R - offset;
            }
        }
        for (; ; i++, x += 1.f) {

            final int hi = i + (fixed >> 1);
            final int lo = hi - fixed;
            if (hi >= n) {
                break;
            }

            tN = N[hi] - N[lo];
            tX = X[hi] - X[lo];
            tXX = XX[hi] - XX[lo];
            tY = Y[hi] - Y[lo];
            tXY = XY[hi] - XY[lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;

            if (R - offset < noise[i]) {
                noise[i] = R - offset;
            }
        }
        for (; i < n; i++, x += 1.f) {
            R = (A + x * B) / D;
            if (R - offset < noise[i]) {
                noise[i] = R - offset;
            }
        }
    }

    // private static int seq = 0;

    final void _noisemask(
            final float[] logmdct, int offset,
            final float[] logmask) {

        final int size = this.n;
        final float[] work = new float[size];

        bark_noise_hybridmp(size, this.bark, logmdct, offset, logmask, 140.f, -1);

        int i;
        for (i = 0; i < size; i++) {
            work[i] = logmdct[offset++] - logmask[i];
        }

        bark_noise_hybridmp(size, this.bark, work, 0, logmask, 0.f, this.vi.noisewindowfixed);

        for (i = 0, offset -= size; i < size; i++) {
            work[i] = logmdct[offset++] - work[i];
        }

/*if( false ) {// #if 0
		{

			final float[] work2 = new float[n];
			for( i = 0; i < n; i++ ) {
				work2[i] = logmask[i] + work[i];
			}

			if( (seq & 1) != 0 ) {
				Analysis._analysis_output("median2R", seq / 2, work, 0, n, true, false, 0);
				Analysis._analysis_output("envelope2R", seq / 2, work2, 0, n, true, false, 0);
			} else {
				Analysis._analysis_output("median2L", seq/2, work, 0, n, true, false, 0);
				Analysis._analysis_output("envelope2L", seq / 2, work2, 0, n, true, false, 0);
			}

			seq++;
		}
}// #endif */

        final float[] noisecompand = this.vi.noisecompand;// java
        for (i = 0; i < size; i++) {
            int dB = (int) (logmask[i] + .5f);
            if (dB >= NOISE_COMPAND_LEVELS) {
                dB = NOISE_COMPAND_LEVELS - 1;
            }
            if (dB < 0) {
                dB = 0;
            }
            logmask[i] = work[i] + noisecompand[dB];
        }

    }

    final void _tonemask(
            final float[] logfft,
            final float[] logmask,
            final float global_specmax,
            final float local_specmax) {

        final int size = this.n;

        final int nlines = this.total_octave_lines;// java
        final float[] seed = new float[nlines];
        float att = local_specmax + this.vi.ath_adjatt;
        for (int i = 0; i < nlines; i++) {
            seed[i] = NEGINF;
        }

		/* set the ATH (floating below localmax, not global max by a
		 specified att) */
        if (att < this.vi.ath_maxatt) {
            att = this.vi.ath_maxatt;
        }

        final float[] a = this.ath;// java
        for (int i = 0; i < size; i++) {
            logmask[i] = a[i] + att;
        }

        /* tone masking */
        seed_loop(this.tonecurves, logfft, logmask, seed, global_specmax);
        max_seeds(seed, logmask);

    }

    final void _offset_and_mix(
            final float[] noise,
            final float[] tone,
            final int offset_select,
            final float[] logmask,
            final float[] mdct,
            final int logmdct) {// offset to logmask

        final int size = this.n;
        final float coeffi = -17.2f; /* coeffi is a -17.2dB threshold */
        final float toneatt = this.vi.tone_masteratt[offset_select];

        final float cx = this.val;

        final float[][] no = this.noiseoffset;// java
        final float noisemaxsupp = this.vi.noisemaxsupp;// java
        for (int i = 0; i < size; i++) {
            float v = noise[i] + no[offset_select][i];
            if (v > noisemaxsupp) {
                v = noisemaxsupp;
            }
            logmask[i] = Math.max(v, tone[i] + toneatt);


            /* AoTuV */
            /** @ M1 **
             The following codes improve a noise problem.
             A fundamental idea uses the value of masking and carries out
             the relative compensation of the MDCT.
             However, this code is not perfect and all noise problems cannot be solved.
             by Aoyumi @ 2004/04/18
             */

            if (offset_select == 1) {

                v -= logmask[logmdct + i];  /* val == mdct line value relative to floor in dB */

                float de;/* AoTuV */
                if (v > coeffi) {
                    /* mdct value is > -17.2 dB below floor */

                    de = 1.0f - ((v - coeffi) * 0.005f * cx);
					/* pro-rated attenuation:
					   -0.00 dB boost if mdct value is -17.2dB (relative to floor)
					   -0.77 dB boost if mdct value is 0dB (relative to floor)
					   -1.64 dB boost if mdct value is +17.2dB (relative to floor)
					   etc... */

                    if (de < 0) {
                        de = 0.0001f;
                    }
                } else {
                    de = 1.0f - ((v - coeffi) * 0.0003f * cx);
					/* pro-rated attenuation:
					 +0.00 dB atten if mdct value is -17.2dB (relative to floor)
					 +0.45 dB atten if mdct value is -34.4dB (relative to floor)
					 etc... */
                }

                mdct[i] *= de;

            }
        }
    }

    private static final float[] FLOOR1_fromdB_LOOKUP = {// [256]
            1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
            1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
            1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
            2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
            2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
            3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
            4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
            6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
            7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
            1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
            1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
            1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
            2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
            2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
            3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
            4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
            5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
            7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
            9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
            1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
            1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
            2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
            2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
            3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
            4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
            5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
            7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
            9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
            0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
            0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
            0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
            0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
            0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
            0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
            0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
            0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
            0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
            0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
            0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
            0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
            0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
            0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
            0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
            0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
            0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
            0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
            0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
            0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
            0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
            0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
            0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
            0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
            0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
            0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
            0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
            0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
            0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
            0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
            0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
            0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
            0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
            0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
            0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
            0.82788260F, 0.88168307F, 0.9389798F, 1.F,
    };

    /** this is for per-channel noise normalization */
    /**
     * array to sort
     */
    private float[] mDim;

    private final Comparator sort_comparator_set(final float[] dim) {
        this.mDim = dim;
        return this;
    }

    @Override
    public final int compare(final int a, final int b) {
        final float[] d = this.mDim;// java
        final float f1 = d[a];
        final float f2 = d[b];
        if (f1 < f2) {
            return 1;
        }
        if (f1 > f2) {
            return -1;
        }
        return 0;
    }

    //private final Comparator apsort = this;

    private static final void flag_lossless(final int limit, final float prepoint, final float postpoint,
                                            final float[] mdct, int mdct_offset,
                                            final float[] floor, final boolean[] flag, int offset, final int i, final int jn) {
        for (int j = 0; j < jn; j++) {
            final float point = j >= limit - i ? postpoint : prepoint;
            float r = mdct[mdct_offset++];
            if (r <= 0.0F) {
                r = 0.0F - r;
            }
            r /= floor[offset];
            flag[offset++] = (r >= point);
        }
    }

    /**
     * Overload/Side effect: On input, the *q vector holds either the
     * quantized energy (for elements with the flag set) or the absolute
     * values of the *r vector (for elements with flag unset).  On output,
     * q holds the quantized energy for all elements
     */
    private final float noise_normalize(int limit,
                                        final float[] r, final float[] q, final float[] f, final boolean[] flags, final int offset,
                                        float acc, int i, int length, final int[] out, final int iout_offset) {
        final InfoPsy vinfo = this.vi;
        final int[] sort = new int[length];// index to q[]
        int start = (vinfo.normal_p ? vinfo.normal_start - i : length);
        if (start > length) {
            start = length;
        }
        start += offset;
        length += offset;
        limit -= i;
        limit += offset;

        /* force classic behavior where only energy in the current band is considered */
        acc = 0.f;

		/* still responsible for populating *out where noise norm not in
		 effect.  There's no need to [re]populate *q in these areas */
        int j, k;
        for (j = offset, k = iout_offset; j < start; j++, k++) {
            if (flags == null || !flags[j]) { /* lossless coupling already quantized.
											Don't touch; requantizing based on
											energy would be incorrect. */
                final float ve = q[j] / f[j];
                if (r[j] < 0) {
                    out[k] = (int) -Math.rint(Math.sqrt(ve));
                } else {
                    out[k] = (int) Math.rint(Math.sqrt(ve));
                }
            }
        }

        /* sort magnitudes for noise norm portion of partition */
        int count = 0;
        for (k = j + iout_offset - offset; j < length; j++, k++) {
            if (flags == null || !flags[j]) { /* can't noise norm elements that have
												already been loslessly coupled; we can
												only account for their energy error */
                final float ve = q[j] / f[j];
				/* Despite all the new, more capable coupling code, for now we
				 implement noise norm as it has been up to this point. Only
				 consider promotions to unit magnitude from 0.  In addition
				 the only energy error counted is quantizations to zero. */
                /* also-- the original point code only applied noise norm at > pointlimit */
                if (ve < .25f && (flags == null || j >= limit)) {
                    acc += ve;
                    // sort[count++] = q + j; /* q is fabs(r) for unflagged element */
                    sort[count++] = j;// with + offset
                } else {
                    /* For now: no acc adjustment for nonzero quantization.
                     * populate *out and q as this value is final. */
                    i = (int) Math.rint(Math.sqrt(ve));
                    if (r[j] < 0) {
                        i = -i;
                    }
                    out[k] = i;
                    q[j] = i * i * f[j];
                }
            }/* else{
				again, no energy adjustment for error in nonzero quant-- for now
			}*/
        }

        if (count != 0) {
            /* noise norm to do */
            FastQSortAlgorithm.sort(sort, 0, count, sort_comparator_set(q));

            length = iout_offset - offset;
            for (j = 0; j < count; j++) {
                k = sort[j];// with + offset
                if (acc >= vinfo.normal_thresh) {
                    out[length + k] = r[k] < 0f ? -1 : 1;// java: extracted (int)Codec.unitnorm( r[k] );
                    acc -= 1.f;
                    q[k] = f[k];
                } else {
                    out[length + k] = 0;
                    q[k] = 0.f;
                }
            }
        }

        return acc;
    }

    /**
     * Noise normalization, quantization and coupling are not wholly
     * seperable processes in depth>1 coupling.
     */
    final void _couple_quantize_normalize(final int blobno,
                                          final InfoPsyGlobal g,
                                          final InfoMapping0 vinfo,
                                          final float[][] mdct,
                                          final int[][] iwork,
                                          final boolean[] nonzero,
                                          final int sliding_lowpass,
                                          final int ch) {
        final int size = this.n;
        final int partition = (this.vi.normal_p ? this.vi.normal_partition : 16);
        final int limit = g.coupling_pointlimit[this.vi.blockflag][blobno];
        final float prepoint = stereo_threshholds[g.coupling_prepointamp[blobno]];
        /* The threshold of a stereo is changed with the size of n */
        final float postpoint = (size > 1000) ?
                stereo_threshholds_limited[g.coupling_postpointamp[blobno]] :
                stereo_threshholds[g.coupling_postpointamp[blobno]];

        final int length = ch * partition;
        /* mdct is our raw mdct output, floor not removed. */
        /* inout passes in the ifloor, passes back quantized result */

        /* unquantized energy (negative indicates amplitude has negative sign) */
        final float[] raw = new float[length];

        /* dual pupose; quantized energy (if flag set), othersize fabs(raw) */
        final float[] quant = new float[length];

        /* floor energy */
        final float[] floor = new float[length];

        /* flags indicating raw/quantized status of elements in raw vector */
        final boolean[] flag = new boolean[length];

        final int[] offsets = new int[ch];

        /* non-zero flag working vector */
        final boolean[] nz = new boolean[ch];

        /* energy surplus/defecit tracking */
        final int coupling_steps = vinfo.coupling_steps;// java

        final float[] acc = new float[ch + coupling_steps];

        for (int i = 0; i < ch; i++) {
            offsets[i] = partition * i;
        }
		/* for( int i = 0; i < ch_coupling_steps; i++ ) {// java: already zeroed
			acc[i] = 0.f;
		}*/
        final int[] coupling_mag = vinfo.coupling_mag;// java
        final int[] coupling_ang = vinfo.coupling_ang;// java
        for (int i = 0; i < size; i += partition) {
            int track = size - i;// java
            final int jn = partition > track ? track : partition;
            track = 0;

            System.arraycopy(nonzero, 0, nz, 0, ch);

            /* prefill */
            Arrays.fill(flag, 0, length, false);
            for (int k = 0; k < ch; k++) {
                final int[] iout = iwork[k];
                final float[] m = mdct[k];
                final int offset_k = offsets[k];
                if (nz[k]) {

                    final int je = i + jn;
                    for (int j = i, offset = offset_k; j < je; j++, offset++) {
                        floor[offset] = FLOOR1_fromdB_LOOKUP[iout[j]];
                    }

                    flag_lossless(limit, prepoint, postpoint, m, i, floor, flag, offset_k, i, jn);

                    for (int j = i, offset = offset_k; j < je; j++, offset++) {
                        final float v = m[j];
                        quant[offset] = raw[offset] = v * v;
                        if (v < 0.f) {
                            raw[offset] = 0.0F - raw[offset];
                        }
                        floor[offset] *= floor[offset];
                    }

                    acc[track] = noise_normalize(limit, raw, quant, floor, null, offset_k, acc[track], i, jn, iout, i);

                } else {
                    for (int j = 0; j < jn; j++) {
                        final int offset = offset_k + j;
                        floor[offset] = 1e-10f;
                        raw[offset] = 0.f;
                        quant[offset] = 0.f;
                        flag[offset] = false;
                        iout[i + j] = 0;
                    }
                    acc[track] = 0.f;
                }
                track++;
            }

            /* coupling */
            for (int step = 0; step < coupling_steps; step++) {
                final int Mi = coupling_mag[step];
                final int Ai = coupling_ang[step];
                final int oM = offsets[Mi];
                final int oA = offsets[Ai];
                final int[] iM = iwork[Mi];
                final int[] iA = iwork[Ai];

                if (nz[Mi] || nz[Ai]) {
                    nz[Mi] = nz[Ai] = true;

                    for (int j = 0; j < jn; j++) {
                        final int M_j = oM + j;
                        final int A_j = oA + j;
                        if (j < sliding_lowpass - i) {
                            float abs_raw_M_j = raw[M_j];
                            if (abs_raw_M_j <= 0.0F) {
                                abs_raw_M_j = 0.0F - abs_raw_M_j;
                            }
                            if (flag[M_j] || flag[A_j]) {
                                /* lossless coupling */
                                float abs_raw_A_j = raw[A_j];
                                if (abs_raw_A_j <= 0.0F) {
                                    abs_raw_A_j = 0.0F - abs_raw_A_j;
                                }

                                raw[M_j] = abs_raw_M_j + abs_raw_A_j;
                                quant[M_j] = quant[M_j] + quant[A_j];
                                flag[M_j] = flag[A_j] = true;

                                /* couple iM/iA */
                                {
                                    final int i_j = i + j;
                                    int A = iM[i_j];
                                    final int B = iA[i_j];

                                    if (((A < 0) ? -A : A) > ((B < 0) ? -B : B)) {
                                        iA[i_j] = (A > 0 ? A - B : B - A);
                                    } else {
                                        iA[i_j] = (B > 0 ? A - B : B - A);
                                        iM[i_j] = B;
                                    }

                                    /* collapse two equivalent tuples to one */
                                    A = iM[i_j];
                                    if (A < 0) {
                                        A = -A;
                                    }
                                    A <<= 1;
                                    if (iA[i_j] >= A) {
                                        iA[i_j] = -iA[i_j];
                                        iM[i_j] = -iM[i_j];
                                    }

                                }

                            } else {
                                /* lossy (point) coupling */
                                if (j < limit - i) {
                                    /* dipole */
                                    raw[M_j] += raw[A_j];
                                    quant[M_j] = abs_raw_M_j;
                                } else {
/*if( false ) {//#if 0
									// AoTuV
									float de = 0.1f * this.m_val;// a blend of the AoTuV M2 and M3 code here and below
									// @ M2
									//	The boost problem by the combination of noise normalization and point stereo is eased.
									//	However, this is a temporary patch.
									//	by Aoyumi @ 2004/04/18
									//
									float derate = (1.0f - de * ((float)(j - limit + i) / (float)(n - limit)));
									// elliptical
									float abs_raw_A_j = raw[A_j];
									if( abs_raw_A_j <= 0.0F ) abs_raw_A_j = 0.0F - abs_raw_A_j;
									if( raw[M_j] + raw[A_j] < 0 ) {
										raw[M_j] = - (quant[M_j] = (abs_raw_M_j + abs_raw_A_j) * derate * derate);
									} else {
										raw[M_j] =   (quant[M_j] = (abs_raw_M_j + abs_raw_A_j) * derate * derate);
									}
} else */
                                    {// #else
                                        /* elliptical */
                                        float abs_raw_A_j = raw[A_j];
                                        if (abs_raw_A_j <= 0.0F) {
                                            abs_raw_A_j = 0.0F - abs_raw_A_j;
                                        }
                                        if (raw[M_j] + raw[A_j] < 0) {
                                            raw[M_j] = -(quant[M_j] = abs_raw_M_j + abs_raw_A_j);
                                        } else {
                                            raw[M_j] = (quant[M_j] = abs_raw_M_j + abs_raw_A_j);
                                        }
                                    }// #endif

                                }
                                raw[A_j] = quant[A_j] = 0.f;
                                flag[A_j] = true;
                                iA[i + j] = 0;
                            }
                        }
                        floor[M_j] = floor[M_j] = floor[M_j] + floor[A_j];
                    }
                    /* normalize the resulting mag vector */
                    acc[track] = noise_normalize(limit, raw, quant, floor, flag, oM, acc[track], i, jn, iM, i);

                    track++;
                }
            }
        }

        for (int i = 0; i < coupling_steps; i++) {
			/* make sure coupling a zero and a nonzero channel results in two
			   nonzero channels. */
            final int m = coupling_mag[i];// java
            final int a = coupling_ang[i];// java
            if (nonzero[m] || nonzero[a]) {
                nonzero[m] = true;
                nonzero[a] = true;
            }
        }
    }
}
